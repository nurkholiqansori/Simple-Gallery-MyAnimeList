"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[970],{2804:function(e,t,n){n.d(t,{Wh:function(){return gs},cn:function(){return Ss},FV:function(){return bs}});var o=n(7294),r=n(3935);var a=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(n){}return t};var s=function(e){return!!e&&"function"===typeof e.then};var i=function(e,t){if(null!=e)return e;throw a(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class u{getValue(){throw a("BaseLoadable")}toPromise(){throw a("BaseLoadable")}valueMaybe(){throw a("BaseLoadable")}valueOrThrow(){throw a(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw a("BaseLoadable")}promiseOrThrow(){throw a(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw a("BaseLoadable")}errorOrThrow(){throw a(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw a("BaseLoadable")}}class l extends u{constructor(e){super(),c(this,"state","hasValue"),c(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return s(t)?v(t):m(t)?t:h(t)}catch(t){return s(t)?v(t.next((()=>this.map(e)))):p(t)}}}class d extends u{constructor(e){super(),c(this,"state","hasError"),c(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class f extends u{constructor(e){super(),c(this,"state","loading"),c(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return v(this.contents.then((t=>{const n=e(t);if(m(n)){const e=n;switch(e.state){case"hasValue":return e.contents;case"hasError":throw e.contents;case"loading":return e.contents}}return n})).catch((t=>{if(s(t))return t.then((()=>this.map(e).contents));throw t})))}}function h(e){return Object.freeze(new l(e))}function p(e){return Object.freeze(new d(e))}function v(e){return Object.freeze(new f(e))}function y(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?h(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?p(i(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):v(Promise.all(e.map((e=>e.contents))))}(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t])));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function m(e){return e instanceof u}const _={of:e=>s(e)?v(e):h(e),error:e=>p(e),all:y,isLoadable:m};var g={loadableWithValue:h,loadableWithError:p,loadableWithPromise:v,loadableLoading:function(){return Object.freeze(new f(new Promise((()=>{}))))},loadableAll:y,isLoadable:m,RecoilLoadable:_},S=g.loadableWithValue,b=g.loadableWithError,w=g.loadableWithPromise,T=g.loadableLoading,R=g.loadableAll,A=g.isLoadable,E=g.RecoilLoadable,N=Object.freeze({__proto__:null,loadableWithValue:S,loadableWithError:b,loadableWithPromise:w,loadableLoading:T,loadableAll:R,isLoadable:A,RecoilLoadable:E});var k,V=function(e,...t){0};const L=null!==(k=o.useMutableSource)&&void 0!==k?k:o.unstable_useMutableSource;var M={mutableSourceExists:function(){return L&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:L};const{mutableSourceExists:C}=M,U=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0).set("recoil_suppress_rerender_in_callback",!0);function B(e){var t;return!("recoil_early_rendering_2021"===e&&!C())&&(null!==(t=U.get(e))&&void 0!==t&&t)}B.setPass=e=>{U.set(e,!0)},B.setFail=e=>{U.set(e,!1)};var D=B;var x=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var I=function(e,t,{error:n}={}){return null};class z{constructor(e){c(this,"key",void 0),this.key=e}}class O extends z{}class P extends z{}var F={AbstractRecoilValue:z,RecoilState:O,RecoilValueReadOnly:P,isRecoilValue:function(e){return e instanceof O||e instanceof P}},$=F.AbstractRecoilValue,W=F.RecoilState,j=F.RecoilValueReadOnly,q=F.isRecoilValue,G=Object.freeze({__proto__:null,AbstractRecoilValue:$,RecoilState:W,RecoilValueReadOnly:j,isRecoilValue:q});class H{}const K=new H;class Z extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const J=new Map,Q=new Map;class X extends Error{}const Y=new Map;function ee(e){return Y.get(e)}var te={nodes:J,recoilValues:Q,registerNode:function(e){if(J.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}J.set(e.key,e);const t=null==e.set?new G.RecoilValueReadOnly(e.key):new G.RecoilState(e.key);return Q.set(e.key,t),t},getNode:function(e){const t=J.get(e);if(null==t)throw new X(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return J.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!D("recoil_memory_managament_2020"))return;const n=J.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(J.delete(e),null===(o=ee(e))||void 0===o||o(),Y.delete(e))},setConfigDeletionHandler:function(e,t){D("recoil_memory_managament_2020")&&(void 0===t?Y.delete(e):Y.set(e,t))},getConfigDeletionHandler:ee,recoilValuesForKeys:function(e){return x(e,(e=>i(Q.get(e))))},NodeMissingError:X,DefaultValue:H,DEFAULT_VALUE:K,RecoilValueNotReady:Z};var ne={enqueueExecution:function(e,t){t()}};var oe,re=(function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},c=function(e){return function(){return e}},u=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),c=l(n,a);return g(t,d(i)|d(c),i===c?[e(t,n+5,o,r,a,s)]:i<c?[r,s]:[s,r])},w=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,s){if(t(a,this.key)){var c=o(this.value);return c===this.value?this:c===i?(--s.value,v):w(e,this)?(this.value=c,this):m(e,r,a,c)}var u=o();return u===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,u)))},R=function(e,t,n,o,r,a,s){if(r===this.hash){var c=function(e,t,n,o,r,a,s,c){for(var u=r.length,l=0;l<u;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--c.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++c.value,h(e,u,m(t,o,s,y),r))}(w(e,this),e,t,this.hash,this.children,o,a,s);return c===this.children?this:c.length>1?_(e,this.hash,c):c[0]}var u=o();return u===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,u)))},A=function(e,t,n,o,r,s,i){var c=this.mask,u=this.children,m=l(n,r),_=d(m),b=f(c,_),T=c&_,R=T?u[b]:v,A=R._modify(e,t,n+5,o,r,s,i);if(R===A)return this;var E,N=w(e,this),k=c,V=void 0;if(T&&y(A)){if(!(k&=~_))return v;if(u.length<=2&&((E=u[1^b])===v||1===E.type||2===E.type))return u[1^b];V=p(N,b,u)}else if(T||y(A))V=h(N,b,A,u);else{if(u.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,c=0;s;++c)1&s&&(a[c]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,m,A,c,u);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,c=new Array(r+1);s<t;)c[i++]=o[s++];for(c[t]=n;s<r;)c[++i]=o[s++];return c}(N,b,A,u)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,i){var c=this.size,u=this.children,d=l(n,r),f=u[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=w(e,this),_=void 0;if(y(f)&&!y(p))++c,_=h(m,d,p,u);else if(!y(f)&&y(p)){if(--c<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,c=o.length;i<c;++i)if(i!==n){var u=o[i];u&&!y(u)&&(r[a++]=u,s|=1<<i)}return g(e,s,r)}(e,c,d,u);_=h(m,d,v,u)}else _=h(m,d,p,u);return m?(this.size=c,this.children=_,this):S(e,c,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var c=o();return c===i?v:(++s.value,m(e,r,a,c))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,c=0,u=i.length;c<u;++c){var h=i[c];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||u},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var x=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return x(t,e,this)};var I=n.setHash=function(e,t,n,o){return D(c(n),e,t,o)};N.prototype.setHash=function(e,t,n){return I(e,t,n,this)};var z=n.set=function(e,t,n){return I(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return z(e,t,this)};var O=c(i),P=n.removeHash=function(e,t,n){return D(O,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return P(e,t,this)};var F=n.remove=function(e,t){return P(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var $=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return $(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var j=n.mutate=function(e,t){var n=$(t);return e(n),W(n)};N.prototype.mutate=function(e){return j(e,this)};var q=function(e){return e&&G(e[0],e[1],e[2],e[3],e[4])},G=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return q(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return G(o.length,o,0,t,n);default:return q(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=q(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},Q=function(e){return[e.key,e.value]},X=n.entries=function(e){return J(e,Q)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var c=a[s++];c&&c.type&&(1===c.type?t=e(t,c.value,c.key):r.push(c.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(oe={exports:{}},oe.exports),oe.exports);class ae{constructor(e){c(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return ie(this)}toMap(){return new Map(this._map)}}class se{constructor(e){if(c(this,"_hamt",re.empty.beginMutation()),e instanceof se){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return ie(this)}toMap(){return new Map(this._hamt)}}function ie(e){return D("recoil_hamt_2020")?new se(e):new ae(e)}var ce=ie,ue=Object.freeze({__proto__:null,persistentMap:ce});var le=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var de=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function fe(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:le(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);i(r.get(e)).add(t)})),a){le(a,e).forEach((e=>{if(!r.has(e))return;const n=i(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var he={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),i(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:de(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:de(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=i(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&I("Tried to save dependencies to a discarded tree");const c=t.getGraph(n);if(fe(e,c),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){fe(e,t.getGraph(i.currentTree.version),c)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var u;const n=null===(u=i.nextTree)||void 0===u?void 0:u.version;if(void 0!==n){fe(e,t.getGraph(n),c)}}}};const{persistentMap:pe}=ue,{graph:ve}=he;let ye=0;const me=()=>ye++;function _e(){const e=me();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:pe(),nonvalidatedAtoms:pe()}}var ge={makeEmptyTreeState:_e,makeEmptyStoreState:function(){const e=_e();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,ve()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:me};var Se=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var be={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var we=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};class Te{}var Re={RetentionZone:Te,retentionZone:function(){return new Te}};const{setByAddingToSet:Ae}=be,{getNode:Ee,getNodeMaybe:Ne,recoilValuesForKeys:ke}=te,{RetentionZone:Ve}=Re,Le=Object.freeze(new Set);class Me extends Error{}function Ce(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Ee(n),s=function(e,t,n){if(!D("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Ve)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!D("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof Ve)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Ue(e,t,n){return Ee(n).peek(e,t)}function Be(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:Le;for(const t of e)o.has(t)||r.push(t)}return o}var De={getNodeLoadable:function(e,t,n){return Ce(e,t,n,"get"),Ee(n).get(e,t)},peekNodeLoadable:Ue,setNodeValue:function(e,t,n,o){const r=Ee(n);if(null==r.set)throw new Me(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Ce(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=Ne(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Ae(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const s=e.getState(),i=e.getGraph(t.version),c=s.knownAtoms.has(n)?"atom":s.knownSelectors.has(n)?"selector":void 0,u=we(Be(e,t,new Set([n])),(e=>e!==n));return{loadable:Ue(e,t,n),isActive:s.knownAtoms.has(n)||s.knownSelectors.has(n),isSet:"selector"!==c&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:c,deps:ke(null!==(o=i.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:ke(u),components:x(null!==(r=null===(a=s.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:Be,initializeNodeIfNewToStore:Ce};const{getDownstreamNodes:xe,getNodeLoadable:Ie,setNodeValue:ze}=De,{getNodeMaybe:Oe}=te,{DefaultValue:Pe,RecoilValueNotReady:Fe}=te,{AbstractRecoilValue:$e,RecoilState:We,RecoilValueReadOnly:je,isRecoilValue:qe}=G;function Ge(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=Ie(e,t,n);if("loading"===r.state)throw new Fe(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=ze(e,t,o.key,a);for(const[e,n]of s.entries())He(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;He(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=Oe(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else I(`Unknown action ${n.type}`)}function He(e,t,n){"hasValue"===n.state&&n.contents instanceof Pe?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function Ke(e,t){e.replaceState((n=>{const o=Qe(n);for(const r of t)Ge(e,o,r);return Xe(e,o),o}))}function Ze(e,t){if(Je.length){const n=Je[Je.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else Ke(e,[t])}const Je=[];function Qe(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Xe(e,t){const n=xe(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=Oe(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function Ye(e,t,n){Ze(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let et=0;var tt={RecoilValueReadOnly:je,AbstractRecoilValue:$e,RecoilState:We,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&I("Tried to read from a discarded tree");const s=Ie(e,n,t);return"loading"===s.state&&s.contents.catch((()=>{})),s},setRecoilValue:Ye,setRecoilValueLoadable:function(e,t,n){if(n instanceof Pe)return Ye(e,t,n);Ze(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){Ze(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){Ze(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=et++,a=e.getState();if(a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),i(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),D("recoil_early_rendering_2021")){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):I(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:qe,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof Pe?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return Je.push(e),()=>{for(const[t,n]of e)Ke(t,n);Je.pop()!==e&&I("Incorrect order of batch popping")}},writeLoadableToTreeState:He,invalidateDownstreams:Xe,copyTreeState:Qe,invalidateDownstreams_FOR_TESTING:Xe};var nt=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:ot}=De,{deleteNodeConfigIfPossible:rt,getNode:at}=te,{RetentionZone:st}=Re,it=new Set;function ct(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void I("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const s of t)if(s instanceof st)for(const e of lt(n,s))r.add(e);else r.add(s);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return c(t),a;function c(t){const u=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],c=new Set;for(;n.size>0;)u(i(n.values().next().value));return s;function u(e){if(o.has(e)||r.has(e))return void n.delete(e);if(c.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)u(n);c.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===at(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(dt(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&nt(t,(e=>s.has(e)))?s.add(e):(a.add(e),u.add(e))}const f=new Set;for(const e of u)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:it){var h;a.has(t)||f.add(t)}f.size&&c(f)}}(e,r);for(const s of a)ut(e,o,s)}function ut(e,t,n){if(!D("recoil_memory_managament_2020"))return;ot(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=dt(n);for(const c of r){var a;null===(a=o.retention.nodesRetainedByZone.get(c))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}rt(n)}function lt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:it}function dt(e){const t=at(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof st?[t]:t}function ft(e,t){if(!D("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):ct(e,new Set([t]))}(e,t)}var ht={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!D("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?ft(e,t):r.set(t,a)},updateRetainCountToZero:ft,releaseScheduledRetainablesNow:function(e){if(!D("recoil_memory_managament_2020"))return;const t=e.getState();ct(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var pt=function*(e){for(const t of e)for(const e of t)yield e};var vt={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{unstable_batchedUpdates:yt}=r;var mt={unstable_batchedUpdates:yt};const{unstable_batchedUpdates:_t}=mt;var gt={unstable_batchedUpdates:_t};const{batchStart:St}=tt,{unstable_batchedUpdates:bt}=gt;let wt=bt;var Tt={getBatcher:()=>wt,setBatcher:e=>{wt=e},batchUpdates:e=>{wt((()=>{let t=()=>{};try{t=St(),e()}finally{t()}}))}};const{isSSR:Rt}=vt,{batchUpdates:At}=Tt,{initializeNodeIfNewToStore:Et,peekNodeInfo:Nt}=De,{graph:kt}=he,{DEFAULT_VALUE:Vt,recoilValues:Lt,recoilValuesForKeys:Mt}=te,{AbstractRecoilValue:Ct,getRecoilValueAsLoadable:Ut,setRecoilValue:Bt,setUnvalidatedRecoilValue:Dt}=tt,{updateRetainCount:xt}=ht,{getNextTreeStateVersion:It,makeEmptyStoreState:zt}=ge;class Ot{constructor(e){c(this,"_store",void 0),c(this,"_refCount",0),c(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),Ut(this._store,e)))),c(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),c(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return Mt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?Lt.values():!0===e.isInitialized?Mt(pt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):we(Lt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),c(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),Nt(this._store,this._store.getState().currentTree,e)))),c(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new $t(this,At);return e(t),Ft(t.getStore_INTERNAL())})),c(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new $t(this,At);return await e(t),Ft(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return i(n.get(t));const o=kt();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw a("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())Et(this._store,e.currentTree,t,"get"),xt(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!D("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){D("recoil_memory_managament_2020")&&(Rt||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){D("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){D("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Pt(e,t,n=!1){const o=e.getState(),r=n?It():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Ft(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:i(n.previousTree);return new Ot(Pt(e,o))}class $t extends Ot{constructor(e,t){super(Pt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),c(this,"_batch",void 0),c(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{xt(n,e.key,1),Bt(this.getStore_INTERNAL(),e,t)}))})),c(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{xt(t,e.key,1),Bt(this.getStore_INTERNAL(),e,Vt)}))})),c(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();At((()=>{for(const[n,o]of e.entries())xt(t,n,1),Dt(t,new Ct(n),o)}))})),this._batch=t}}var Wt={Snapshot:Ot,MutableSnapshot:$t,freshSnapshot:function(e){const t=new Ot(zt());return null!=e?t.map(e):t},cloneSnapshot:Ft},jt=Wt.Snapshot,qt=Wt.MutableSnapshot,Gt=Wt.freshSnapshot,Ht=Wt.cloneSnapshot,Kt=Object.freeze({__proto__:null,Snapshot:jt,MutableSnapshot:qt,freshSnapshot:Gt,cloneSnapshot:Ht});const{getNextTreeStateVersion:Zt,makeEmptyStoreState:Jt}=ge,{cleanUpNode:Qt,getDownstreamNodes:Xt,setNodeValue:Yt,setUnvalidatedAtomValue_DEPRECATED:en}=De,{graph:tn}=he,{cloneGraph:nn}=he,{applyAtomValueWrites:on}=tt,{releaseScheduledRetainablesNow:rn}=ht,{freshSnapshot:an}=Kt,{useCallback:sn,useContext:cn,useEffect:un,useMemo:ln,useRef:dn,useState:fn}=o;function hn(){throw a("This component must be used inside a <RecoilRoot> component.")}const pn=Object.freeze({getState:hn,replaceState:hn,getGraph:hn,subscribeToTransactions:hn,addTransactionMetadata:hn});let vn=!1;function yn(e){if(vn)throw a("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){D("recoil_memory_managament_2020")&&D("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&rn(e);const n=t.currentTree.version,o=Zt();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,nn(i(t.graphsByVersion.get(n))))}}const mn=o.createContext({current:pn}),_n=()=>cn(mn),gn=o.createContext(null);function Sn(e,t,n){const o=Xt(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function bn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);D("recoil_early_rendering_2021")&&!t.suspendedComponentResolvers.size||(Sn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function wn({setNotifyBatcherOfChange:e}){const t=_n(),[n,o]=fn([]);return e((()=>o({}))),un((()=>{ne.enqueueExecution("Batcher",(()=>{!function(e){const t=e.current.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,bn(e.current),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):I("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,D("recoil_memory_managament_2020")&&rn(e.current)}finally{t.commitDepth--}}(t)}))})),un((()=>()=>{e((()=>{}))}),[e]),null}let Tn=0;function Rn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){var a;let s;const c=dn(null),u=sn((e=>{c.current=e}),[c]),l=null!==(a=o.createMutableSource)&&void 0!==a?a:o.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>s.current,replaceState:e=>{const t=f.current.getState();yn(f.current);const n=i(t.nextTree);let o;try{vn=!0,o=e(n)}finally{vn=!1}o!==n&&(t.nextTree=o,D("recoil_early_rendering_2021")&&Sn(d,t,o),i(c.current)())},getGraph:e=>{const t=s.current.graphsByVersion;if(t.has(e))return i(t.get(e));const n=tn();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=Tn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=Tn++;return i(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{yn(f.current);for(const t of Object.keys(e))i(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=dn(d);s=dn(null!=e?function(e,t){const n=Jt();return t({set:(t,o)=>{const r=n.currentTree,a=Yt(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:Se(r.dirtyAtoms,s),atomValues:on(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=en(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return an().map(e).getStore_INTERNAL().getState()}(t):Jt());const h=ln((()=>l?l(s,(()=>s.current.currentTree.version)):null),[l,s]);return un((()=>()=>{for(const e of f.current.getState().knownAtoms)Qt(f.current,e)}),[]),o.createElement(mn.Provider,{value:f},o.createElement(gn.Provider,{value:h},o.createElement(wn,{setNotifyBatcherOfChange:u}),r))}var An={useStoreRef:_n,useRecoilMutableSource:function(){const e=cn(gn);return null==e&&V("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,r=_n();return!1===t&&r.current!==pn?e.children:o.createElement(Rn,n)},notifyComponents_FOR_TESTING:Sn,sendEndOfBatchNotifications_FOR_TESTING:bn};const{useRef:En}=o;var Nn=function(){return En(),"<component name not available>"};var kn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:Vn,useRef:Ln}=o;var Mn=function(e){const t=Ln();return Vn((()=>{t.current=e})),t.current};const{useStoreRef:Cn}=An,{SUSPENSE_TIMEOUT_MS:Un}=ht,{updateRetainCount:Bn}=ht,{RetentionZone:Dn}=Re,{isSSR:xn}=vt,{useEffect:In,useRef:zn}=o;var On=function(e){if(D("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Dn?e:e.key)),n=Cn();In((()=>{if(!D("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!xn)window.clearTimeout(o.current),o.current=null;else for(const n of t)Bn(e,n,1);return()=>{for(const n of t)Bn(e,n,-1)}}),[n,...t]);const o=zn(),r=Mn(t);if(!xn&&(void 0===r||!kn(r,t))){const e=n.current;for(const n of t)Bn(e,n,1);if(r)for(const t of r)Bn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Bn(e,n,-1)}),Un)}}(e)};const{batchUpdates:Pn}=Tt,{DEFAULT_VALUE:Fn}=te,{useRecoilMutableSource:$n,useStoreRef:Wn}=An,{isRecoilValue:jn}=G,{AbstractRecoilValue:qn,getRecoilValueAsLoadable:Gn,setRecoilValue:Hn,setUnvalidatedRecoilValue:Kn,subscribeToRecoilValue:Zn}=tt,{setByAddingToSet:Jn}=be,{mutableSourceExists:Qn,useMutableSource:Xn}=M,{useCallback:Yn,useEffect:eo,useMemo:to,useRef:no,useState:oo}=o;function ro(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:a(`Invalid value of loadable atom "${t.key}"`)}function ao(e){return D("recoil_memory_managament_2020")&&On(e),Qn()?function(e){const t=Wn(),n=Yn((()=>{var n;const o=t.current,r=o.getState(),a=D("recoil_early_rendering_2021")&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return Gn(o,e,a)}),[t,e]),o=Yn((()=>n()),[n]),r=Nn(),a=Yn(((o,a)=>{const s=t.current;return Zn(s,e,(()=>{if(!D("recoil_suppress_rerender_in_callback"))return a();const e=n();c.current.is(e)||a(),c.current=e}),r).release}),[t,e,r,n]),s=$n(),i=Xn(s,o,a),c=no(i);return eo((()=>{c.current=i})),i}(e):function(e){const t=Wn(),[n,o]=oo([]),r=Nn();eo((()=>{const n=t.current,a=n.getState(),i=Zn(n,e,(t=>{var r;if(!D("recoil_suppress_rerender_in_callback"))return o([]);const a=Gn(n,e,n.getState().currentTree);(null===(r=s.current)||void 0===r?void 0:r.is(a))||o(a),s.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,o([])}));else{var c;if(!D("recoil_suppress_rerender_in_callback"))return o([]);const t=Gn(n,e,n.getState().currentTree);(null===(c=s.current)||void 0===c?void 0:c.is(t))||o(t),s.current=t}return i.release}),[r,e,t]);const a=Gn(t.current,e),s=no(a);return eo((()=>{s.current=a})),a}(e)}function so(e){const t=Wn();return ro(ao(e),e,t)}function io(e){const t=Wn();return Yn((n=>{Hn(t.current,e,n)}),[t,e])}var co={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=Wn(),[,t]=oo([]),n=no(new Set);n.current=new Set;const o=no(new Set),r=no(new Map),a=Yn((e=>{const t=r.current.get(e);t&&(t.release(),r.current.delete(e))}),[r]),s=Nn();return eo((()=>{const i=e.current;function c(e,n){r.current.has(n)&&t([])}le(n.current,o.current).forEach((e=>{if(r.current.has(e))return void V(`Double subscription to RecoilValue "${e}"`);const t=Zn(i,new qn(e),(t=>{c(0,e)}),s);r.current.set(e,t);i.getState().nextTree?i.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{c(i.getState(),e)})):c(i.getState(),e)})),le(o.current,n.current).forEach((e=>{a(e)})),o.current=n.current})),eo((()=>{const e=r.current;return()=>e.forEach(((e,t)=>a(t)))}),[a]),to((()=>{function t(t){return n=>{Hn(e.current,t,n)}}function o(t){var o;n.current.has(t.key)||(n.current=Jn(n.current,t.key));const r=e.current.getState();return Gn(e.current,t,D("recoil_early_rendering_2021")&&null!==(o=r.nextTree)&&void 0!==o?o:r.currentTree)}function r(t){return ro(o(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:o,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[o(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>Hn(e.current,t,Fn)}}}),[n,e])},useRecoilState:function(e){return[so(e),io(e)]},useRecoilStateLoadable:function(e){return[ao(e),io(e)]},useRecoilValue:so,useRecoilValueLoadable:ao,useResetRecoilState:function(e){const t=Wn();return Yn((()=>{Hn(t.current,e,Fn)}),[t,e])},useSetRecoilState:io,useSetUnvalidatedAtomValues:function(){const e=Wn();return(t,n={})=>{Pn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Kn(e.current,new qn(n),t)))}))}}};var uo=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var lo=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var fo=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:ho}=Tt,{DEFAULT_VALUE:po,getNode:vo,nodes:yo}=te,{useStoreRef:mo}=An,{AbstractRecoilValue:_o,setRecoilValueLoadable:go}=tt,{SUSPENSE_TIMEOUT_MS:So}=ht,{Snapshot:bo,cloneSnapshot:wo}=Kt,{isSSR:To}=vt,{useCallback:Ro,useEffect:Ao,useRef:Eo,useState:No}=o;function ko(e){const t=mo();Ao((()=>t.current.subscribeToTransactions(e).release),[e,t])}function Vo(e){const t=e.atomValues.toMap(),n=de(uo(t,((e,t)=>{const n=vo(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return fo(e.nonvalidatedAtoms.toMap(),n)}var Lo={useRecoilSnapshot:function(){const e=mo(),[t,n]=No((()=>wo(e.current))),o=Mn(t),r=Eo();return Ao((()=>(r.current&&!To&&window.clearTimeout(r.current),t.retain())),[t]),ko(Ro((e=>n(wo(e))),[])),o===t||To||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),So)),t},useGotoRecoilSnapshot:function(){const e=mo();return Ro((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;ho((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&vo(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{go(e.current,new _o(t),a.atomValues.has(t)?i(a.atomValues.get(t)):po)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])},useRecoilTransactionObserver:function(e){ko(Ro((t=>{const n=wo(t,"current"),o=wo(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){ko(Ro((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(I("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Vo(o),a=Vo(n),s=de(yo,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=lo(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:ko};const{peekNodeInfo:Mo}=De,{useStoreRef:Co}=An;var Uo=function(){const e=Co();return({key:t})=>Mo(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:Bo,useStoreRef:Do}=An,{useMemo:xo}=o;var Io=function(){const e=Do().current;return xo((()=>function({children:t}){return o.createElement(Bo,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:zo}=N,{DEFAULT_VALUE:Oo,getNode:Po}=te,{copyTreeState:Fo,getRecoilValueAsLoadable:$o,invalidateDownstreams:Wo,writeLoadableToTreeState:jo}=tt;function qo(e){return"atom"===Po(e.key).nodeType}class Go{constructor(e,t){c(this,"_store",void 0),c(this,"_treeState",void 0),c(this,"_changes",void 0),c(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!qo(e))throw a("Reading selectors within atomicUpdate is not supported");const t=$o(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:a(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),c(this,"set",((e,t)=>{if(!qo(e))throw a("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else this._changes.set(e.key,t)})),c(this,"reset",(e=>{this.set(e,Oo)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=Fo(this._treeState);for(const[t,n]of this._changes)jo(e,t,zo(n));return Wo(this._store,e),e}}var Ho=function(e){return t=>{e.replaceState((n=>{const o=new Go(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Ko=Object.freeze({__proto__:null,atomicUpdater:Ho});var Zo=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:Jo}=Ko,{batchUpdates:Qo}=Tt,{DEFAULT_VALUE:Xo}=te,{useStoreRef:Yo}=An,{setRecoilValue:er}=tt,{Snapshot:tr,cloneSnapshot:nr}=Kt,{useGotoRecoilSnapshot:or}=Lo,{useCallback:rr}=o;class ar{}const sr=new ar;var ir=function(e,t){const n=Yo(),o=or();return rr(((...t)=>{function r(e,t){er(n.current,e,t)}function s(e){er(n.current,e,Xo)}const i=nr(n.current),c=Jo(n.current);let u=sr;return Qo((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw a(n);const l=e({set:r,reset:s,snapshot:i,gotoSnapshot:o,transact_UNSTABLE:c});if("function"!==typeof l)throw a(n);u=l(...t)})),u instanceof ar&&Zo(!1),u}),null!=t?[...t,n]:void 0)};const{getNode:cr}=te,{useStoreRef:ur}=An,{useCallback:lr}=o;var dr=function(e){const t=ur();return lr((()=>{var n;const o=t.current,{currentTree:r}=o.getState(),a=cr(e.key);null===(n=a.clearCache)||void 0===n||n.call(a,o,r)}),[e,t])};const{atomicUpdater:fr}=Ko,{useStoreRef:hr}=An,{useMemo:pr}=o;var vr=function(e,t){const n=hr();return pr((()=>(...t)=>{fr(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const{isReactNative:yr,isSSR:mr}=vt;function _r(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw a("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(s(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>_r(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return _r(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:_r(n,t)]=r;return _r(o,t,n)}return e instanceof Set?_r(Array.from(e).sort(((e,n)=>_r(e,t).localeCompare(_r(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?_r(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${_r(n,t)}:${_r(e[n],t,n)}`)).join(",")}}`}var gr=function(e,t={allowFunctions:!1}){return _r(e,t)};const Sr=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return Sr(e.branches.get(r),t,n)},br=(e,t,n,o,r,a,s)=>{var i;let c;if(null==e)if(0===t.length)c={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[u,l]=e;c={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},c.branches.set(l,br(null,i,c,o,l,a,s))}else if(c=e,t.length){const[n,...r]=t,[i,u]=n;if("branch"!==e.type||e.nodeKey!==i)return I("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),s(),c;e.branches.set(u,br(e.branches.get(u),r,e,o,u,a,s))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,c),c},wr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Tr(e,n,n.parent)):e===t,Tr=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Tr(e,n,n.parent)):e===t,Rr=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Rr(t)),0);var Ar=class{constructor(e){var t,n,o;c(this,"_numLeafs",void 0),c(this,"_root",void 0),c(this,"_onHit",void 0),c(this,"_onSet",void 0),c(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return Sr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=br(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(i(o))}delete(e){if(!this.root())return!1;const t=i(this.root());return!!wr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Rr(e),!0))}clear(){this._numLeafs=0,this._root=null}},Er=Object.freeze({__proto__:null,TreeCache:Ar});var Nr=class{constructor(e){var t;c(this,"_maxSize",void 0),c(this,"_size",void 0),c(this,"_head",void 0),c(this,"_tail",void 0),c(this,"_map",void 0),c(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=i(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},kr=Object.freeze({__proto__:null,LRUCache:Nr});const{LRUCache:Vr}=kr,{TreeCache:Lr}=Er;var Mr=function(e,t=(e=>e)){const n=new Vr({maxSize:e}),o=new Lr({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:Cr}=Er,Ur={equality:"reference",eviction:"keep-all",maxSize:1/0};var Br=function({equality:e=Ur.equality,eviction:t=Ur.eviction,maxSize:n=Ur.maxSize}=Ur){return function(e,t,n){switch(e){case"keep-all":return new Cr({mapNodeValue:n});case"lru":return Mr(i(t),n);case"most-recent":return Mr(1,n)}throw a(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>gr(e)}throw a(`Unrecognized equality policy ${e}`)}(e))};var Dr={startPerfBlock:function(e){return()=>null}};const{loadableWithError:xr,loadableWithPromise:Ir,loadableWithValue:zr}=N,{getNodeLoadable:Or,peekNodeLoadable:Pr,setNodeValue:Fr}=De,{saveDependencyMapToStore:$r}=he,{DEFAULT_VALUE:Wr,RecoilValueNotReady:jr,getConfigDeletionHandler:qr,getNode:Gr,registerNode:Hr}=te,{isRecoilValue:Kr}=G,{AbstractRecoilValue:Zr}=G,{markRecoilValueModified:Jr,setRecoilValueLoadable:Qr}=tt,{retainedByOptionWithDefault:Xr}=ht,{cloneSnapshot:Yr}=Kt,{startPerfBlock:ea}=Dr;class ta{}const na=new ta,oa=[],ra=new Map,aa=(()=>{let e=0;return()=>e++})();var sa=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,c=null!=e.set?e.set:void 0,u=new Set,l=Br(null!==r&&void 0!==r?r:{equality:"reference",eviction:"keep-all"}),d=Xr(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!D("recoil_memory_managament_2020")||h>0}function v(e){return f.has(e)||f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),i(f.get(e))}function y(e){return h++,e.getState().knownSelectors.add(n),()=>{h--,e.getState().knownSelectors.delete(n),f.delete(e)}}function m(){return void 0!==qr(n)&&!p()}function _(e,t,n){if("loading"===t.state){let t=ra.get(n);null==t&&ra.set(n,t=new Set),t.add(e)}}function g(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return i(t.atomValues.get(n));const r=Or(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function S(e,t,n,o,r,a){return t.then((o=>{if(!p())throw M(e,r),na;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,zr(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const s=R(e,n);if(s&&"hasValue"===s.state)return V(s,e),s.contents;if(!C(e,r)){var i;const e=N(n);if("loading"===(null===e||void 0===e||null===(i=e.latestLoadable)||void 0===i?void 0:i.state))return e.latestLoadable.contents}const[c,u]=T(e,n,r);if(C(e,r)&&L(u,e,r),"loading"!==c.state&&(B(n,A(u),c),w(e,n,new Set(u.keys()),r),b(e,c,r)),"hasError"===c.state)throw c.contents;return c.contents})).catch((t=>{if(t instanceof ta)throw I("Selector was released while it had dependencies"),na;if(!p())throw M(e,r),na;const a=xr(t);throw U(t),B(n,A(o),xr(t)),w(e,n,new Set(o.keys()),r),b(e,a,r),t}))}function b(e,t,o){C(e,o)&&(V(t,e),function(e,t){const o=ra.get(t);if(void 0!==o){for(const t of o)Qr(t,new Zr(n),e);ra.delete(t)}}(t,o))}function w(e,t,o,r){var a,s,i,c,u,l,d;(C(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||t.version===(null===(i=e.getState())||void 0===i||null===(c=i.nextTree)||void 0===c?void 0:c.version))&&$r(new Map([[n,o]]),e,null!==(u=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==u?u:e.getState().currentTree.version)}function T(e,t,r){const i=ea(n);let c,u,l=!1;const d={loadingDepKey:null,loadingDepPromise:null},f=new Map,h=new Set;function v(n){const{key:o}=n;!function(e,t,n,o,r){n.add(o),w(e,t,n,r)}(e,t,h,o,r);const s=g(e,t,o);switch(f.set(o,s),s.state){case"hasValue":return s.contents;case"hasError":throw s.contents;case"loading":throw d.loadingDepKey=o,d.loadingDepPromise=s.contents,s.contents}throw a("Invalid Loadable state")}w(e,t,h,r);let y=!1;const m=t=>(...n)=>{if(!y)throw a("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=Yr(e),r=t({snapshot:o});if("function"!==typeof r)throw a("getCallback() expects a function that returns a function.");return r(...n)};try{c=o({get:v,getCallback:m}),c=Kr(c)?v(c):c,y=!0,s(c)?c=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw M(e,r),na;const a=zr(t);return U(t),B(n,A(o),a),w(e,n,new Set(o.keys()),r),b(e,a,r),t})).catch((t=>{if(!p())throw M(e,r),na;if(C(e,r)&&L(o,e,r),s(t))return S(e,t,n,o,r,a);const i=xr(t);throw U(t),B(n,A(o),i),w(e,n,new Set(o.keys()),r),b(e,i,r),t}))}(e,c,t,f,r,d).finally(i):i()}catch(_){c=_,s(c)?c=S(e,c,t,f,r,d).finally(i):(l=!0,i())}return u=l?xr(c):s(c)?Ir(c):zr(c),"loading"!==u.state&&U(u.contents),[u,f]}function R(e,t){const o=new Set,r=v(e);let s;try{s=l.get((n=>{"string"!==typeof n&&Zo(!1);return g(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&"string"===typeof e.nodeKey&&(o.add(e.nodeKey),u.add(e.nodeKey))}})}catch(i){throw a(`Problem with cache lookup for selector "${n}": ${i.message}`)}return s&&w(e,t,o,r.latestExecutionId),s}function A(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function E(e,t){const n=aa(),[o,r]=T(e,t,n);return V(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&B(e,t,n)}(t,A(r),o),_(e,o,n),o}function N(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=v(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=k.get(t.version))&&void 0!==o?o:new Map).entries()),i=k.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||i)return!1;return k.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>g(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const k=new Map;function V(e,t,n,o,r){const a=v(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function L(e,t,n){const o=v(t);C(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function M(e,t){C(e,t)&&f.delete(e)}function C(e,t){return t===v(e).latestExecutionId}function U(e){0}function B(e,t,o){e.atomValues.set(n,o);try{l.set(t,o)}catch(r){throw a(`Problem with setting cache for selector "${n}": ${r.message}`)}}function x(e,t){return l.get((n=>{"string"!==typeof n&&Zo(!1);const o=Pr(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function z(e,t){return function(e){if(oa.includes(n)){const e=`Recoil selector has circular dependencies: ${oa.slice(oa.indexOf(n)).join(" \u2192 ")}`;return xr(a(e))}oa.push(n);try{return e()}finally{oa.pop()}}((()=>function(e,t){const n=R(e,t);if(null!=n)return V(n,e),n;const o=N(t);if(o){const t=o;return _(e,i(t.latestLoadable),i(t.latestExecutionId)),i(t.latestLoadable)}return E(e,t)}(e,t)))}function O(e){e.atomValues.delete(n)}function P(e,n){null==t&&Zo(!1);for(const t of u){var o;const r=Gr(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}O(n),l.clear(),Jr(e,t)}if(null!=c){return t=Hr({key:n,nodeType:"selector",peek:x,get:z,set:(e,t,n)=>{let o=!1;const r=new Map;function i({key:n}){if(o)throw a("Recoil: Async selector sets are not currently supported.");const r=g(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new jr(n):r.contents}function u(n,s){if(o)throw a("Recoil: Async selector sets are not currently supported.");const c="function"===typeof s?s(i(n)):s;Fr(e,t,n.key,c).forEach(((e,t)=>r.set(t,e)))}const l=c({set:u,get:i,reset:function(e){u(e,Wr)}},n);if(void 0!==l)throw s(l)?a("Recoil: Async selector sets are not currently supported."):a("Recoil: selector set should be a void function.");return o=!0,r},init:y,invalidate:O,clearCache:P,shouldDeleteConfigOnRelease:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=Hr({key:n,nodeType:"selector",peek:x,get:z,init:y,invalidate:O,clearCache:P,shouldDeleteConfigOnRelease:m,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:ia,loadableWithPromise:ca,loadableWithValue:ua}=N,{peekNodeInfo:la}=De,{DEFAULT_VALUE:da,DefaultValue:fa,getConfigDeletionHandler:ha,registerNode:pa,setConfigDeletionHandler:va}=te,{isRecoilValue:ya}=G,{getRecoilValueAsLoadable:ma,markRecoilValueModified:_a,setRecoilValue:ga,setRecoilValueLoadable:Sa}=tt,{retainedByOptionWithDefault:ba}=ht;function wa(e){const{key:t,persistence_UNSTABLE:n}=e,o=ba(e.retainedBy_UNSTABLE);let r,c=0,u=s(e.default)?ca(e.default.then((e=>(u=ua(e),e))).catch((e=>{throw u=ia(e),e}))):ua(e.default);d(e.default);const l=new Map;function d(e){return e}const f=pa({key:t,nodeType:"atom",peek:function(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:u},get:function(e,o){if(o.atomValues.has(t))return i(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return V(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),u;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,da),s=a instanceof fa?u:ua(a);return r=s,r}return u},set:function(e,n,o){if(n.atomValues.has(t)){const e=i(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof fa)return new Map;return r=void 0,(new Map).set(t,ua(o))},init:function(n,o,r){c++;const i=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===u.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||_a(n,f)};u.contents.then(e).catch(e)}let d=da,h=null;if(null!=e.effects_UNSTABLE&&!i){let o=!0;function i(e){if(o&&e.key===t&&!(d instanceof fa)){const e=d;return e instanceof fa?u:s(e)?ca(e.then((e=>e instanceof fa?u.toPromise():e))):ua(e)}return ma(n,e)}function c(e){return i(e).toPromise()}function y(e){var r;const a=la(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,e.key);return!o||e.key!==t||d instanceof fa?a:{...a,isSet:!0,loadable:i(e)}}const m=e=>t=>{if(o){const n=d instanceof fa||s(d)?"hasValue"===u.state?u.contents:da:d;d="function"===typeof t?t(n):t,s(d)&&(d=d.then((t=>(h={effect:e,value:t},t))))}else{if(s(t))throw a("Setting atoms to async values is not implemented.");"function"!==typeof t&&(h={effect:e,value:t}),ga(n,f,"function"===typeof t?n=>{const o=t(n);return h={effect:e,value:o},o}:t)}},_=e=>()=>m(e)(da),g=e=>o=>{n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:s}=n.getState();s||(I("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),s=a);const i=null!==(r=a.atomValues.get(t))&&void 0!==r?r:u;if("hasValue"===i.state){var c,l,d,f;const n=i.contents,r=null!==(c=s.atomValues.get(t))&&void 0!==c?c:u,p="hasValue"===r.state?r.contents:da;(null===(l=h)||void 0===l?void 0:l.effect)!==e||(null===(d=h)||void 0===d?void 0:d.value)!==n?o(n,p,!a.atomValues.has(t)):(null===(f=h)||void 0===f?void 0:f.effect)===e&&(h=null)}}),t)};for(const t of null!==(p=e.effects_UNSTABLE)&&void 0!==p?p:[]){var p;const e=t({node:f,trigger:r,setSelf:m(t),resetSelf:_(t),onSet:g(t),getPromise:c,getLoadable:i,getInfo_UNSTABLE:y});var v;if(null!=e)l.set(n,[...null!==(v=l.get(n))&&void 0!==v?v:[],e])}o=!1}if(!(d instanceof fa)){var y;const e=d,r=s(e)?ca(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&ga(e,f,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Sa(e,f,ia(n)),n}));return o}(n,e)):ua(e);o.atomValues.set(t,r),null===(y=n.getState().nextTree)||void 0===y||y.atomValues.set(t,r)}return()=>{var e;c--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==ha(t)&&c<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return f}function Ta(e){const{default:t,...n}=e;return ya(t)?function(e){const t=Ta({...e,default:da,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof fa?t:i(e.persistence_UNSTABLE).validator(t,da)},effects_UNSTABLE:e.effects_UNSTABLE}),n=sa({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof fa?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return va(n.key,ha(e.key)),n}({...n,default:t}):wa({...n,default:t})}var Ra=Ta;var Aa=class{constructor(e){var t;c(this,"_map",void 0),c(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},Ea=Object.freeze({__proto__:null,MapCache:Aa});const{LRUCache:Na}=kr,{MapCache:ka}=Ea,Va={equality:"reference",eviction:"none",maxSize:1/0};var La=function({equality:e=Va.equality,eviction:t=Va.eviction,maxSize:n=Va.maxSize}=Va){return function(e,t,n){switch(e){case"keep-all":return new ka({mapKey:n});case"lru":return new Na({mapKey:n,maxSize:i(t)});case"most-recent":return new Na({mapKey:n,maxSize:1})}throw a(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>gr(e)}throw a(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:Ma}=te;var Ca=function(e){var t,n;const o=La({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...s}=e,i=Ra({...s,key:`${e.key}__${null!==(n=gr(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return o.set(t,i),Ma(i.key,(()=>{o.delete(t)})),i}};const{setConfigDeletionHandler:Ua}=te;let Ba=0;var Da=function(e){var t,n;const o=La({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=gr(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${Ba++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,c="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let u;if(null!=e.set){const n=e.set;u=sa({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:c})}else u=sa({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:c});return o.set(t,u),Ua(u.key,(()=>{o.delete(t)})),u}};const xa=Da({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Ia=function(e){return xa(e)};const za=Da({key:"__error",get:e=>()=>{throw a(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Oa=function(e){return za(e)};var Pa=function(e){return e};const{loadableWithError:Fa,loadableWithPromise:$a,loadableWithValue:Wa}=N;function ja(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function qa(e){return null!=e&&!s(e)}function Ga(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Ha(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Ka(e,t,n){return Ha(e,n.map(((e,n)=>null==e?Wa(t[n]):s(e)?$a(e):Fa(e))))}var Za={waitForNone:Da({key:"__waitForNone",get:e=>({get:t})=>{const n=Ga(e),[o,r]=ja(t,n);return Ka(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:Da({key:"__waitForAny",get:e=>({get:t})=>{const n=Ga(e),[o,r]=ja(t,n);return r.some((e=>!s(e)))?Ka(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())s(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(Ka(e,o,r))})).catch((a=>{r[n]=a,t(Ka(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:Da({key:"__waitForAll",get:e=>({get:t})=>{const n=Ga(e),[o,r]=ja(t,n);if(r.every((e=>null==e)))return Ha(e,o);const a=r.find(qa);if(null!=a)throw a;return Promise.all(r).then((t=>{return Ha(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:Da({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ga(e),[o,r]=ja(t,n);return r.every((e=>!s(e)))?Ka(e,o,r):Promise.all(r.map(((e,t)=>s(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Ka(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:Da({key:"__noWait",get:e=>({get:t})=>{try{return Wa(t(e))}catch(n){return s(n)?$a(n):Fa(n)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:Ja}=N,{DefaultValue:Qa}=te,{RecoilRoot:Xa}=An,{isRecoilValue:Ya}=G,{retentionZone:es}=Re,{freshSnapshot:ts}=Kt,{useRecoilState:ns,useRecoilStateLoadable:os,useRecoilValue:rs,useRecoilValueLoadable:as,useResetRecoilState:ss,useSetRecoilState:is,useSetUnvalidatedAtomValues:cs}=co,{useGotoRecoilSnapshot:us,useRecoilSnapshot:ls,useRecoilTransactionObserver:ds,useTransactionObservation_DEPRECATED:fs}=Lo,{noWait:hs,waitForAll:ps,waitForAllSettled:vs,waitForAny:ys,waitForNone:ms}=Za;var _s={DefaultValue:Qa,isRecoilValue:Ya,RecoilLoadable:Ja,RecoilRoot:Xa,useRecoilBridgeAcrossReactRoots_UNSTABLE:Io,atom:Ra,selector:sa,atomFamily:Ca,selectorFamily:Da,constSelector:Ia,errorSelector:Oa,readOnlySelector:Pa,noWait:hs,waitForNone:ms,waitForAny:ys,waitForAll:ps,waitForAllSettled:vs,useRecoilValue:rs,useRecoilValueLoadable:as,useRecoilState:ns,useRecoilStateLoadable:os,useSetRecoilState:is,useResetRecoilState:ss,useGetRecoilValueInfo_UNSTABLE:Uo,useRecoilRefresher_UNSTABLE:dr,useRecoilCallback:ir,useRecoilTransaction_UNSTABLE:vr,useGotoRecoilSnapshot:us,useRecoilSnapshot:ls,useRecoilTransactionObserver_UNSTABLE:ds,useTransactionObservation_UNSTABLE:fs,useSetUnvalidatedAtomValues_UNSTABLE:cs,snapshot_UNSTABLE:ts,useRetain:On,retentionZone:es},gs=_s.RecoilRoot,Ss=_s.atom,bs=_s.useRecoilState}}]);